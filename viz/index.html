<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mycelium Substrate ‚Äî Fleet Memory</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #0a0a0f;
            color: #e0e0e8;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            overflow: hidden;
        }
        #viz {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        .tooltip {
            position: absolute;
            padding: 12px 16px;
            background: rgba(10, 10, 15, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            max-width: 320px;
            backdrop-filter: blur(8px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }
        .tooltip-header {
            color: #6B8E9B;
            font-weight: bold;
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .tooltip-content {
            color: #d0d0d8;
            line-height: 1.5;
        }
        .legend {
            position: fixed;
            bottom: 24px;
            left: 24px;
            background: rgba(10, 10, 15, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 16px;
            font-size: 11px;
            backdrop-filter: blur(8px);
        }
        .legend-title {
            color: #6B8E9B;
            font-weight: bold;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
        }
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .legend-line {
            width: 20px;
            height: 2px;
            margin-right: 10px;
        }
        .title {
            position: fixed;
            top: 24px;
            left: 24px;
            font-size: 14px;
            color: #6B8E9B;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        .subtitle {
            position: fixed;
            top: 44px;
            left: 24px;
            font-size: 11px;
            color: #4a5a63;
        }
        .stats {
            position: fixed;
            top: 24px;
            right: 24px;
            text-align: right;
            font-size: 11px;
            color: #4a5a63;
        }
        .stat-value {
            color: #6B8E9B;
            font-weight: bold;
        }
        svg {
            width: 100%;
            height: 100%;
        }
        .node {
            cursor: pointer;
        }
        .agent-label {
            font-size: 16px;
            font-weight: 800;
            letter-spacing: 1.5px;
            text-shadow: 0 0 20px currentColor, 0 0 40px currentColor;
            pointer-events: none;
        }
        .agent-glow {
            filter: drop-shadow(0 0 8px currentColor) drop-shadow(0 0 16px currentColor);
        }
        .link {
            stroke-opacity: 0.3;
            transition: stroke-opacity 0.3s;
        }
        .link:hover {
            stroke-opacity: 0.8;
        }
        .ghost-label {
            font-size: 9px;
            fill: #5a6a73;
            opacity: 0.6;
        }
        .resonance-ring {
            animation: pulse 3s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.1); }
        }
    </style>
</head>
<body>
    <div class="title">üçÑ Mycelium Substrate</div>
    <div class="subtitle">Fleet Memory Graph v2.0 ‚Äî All Agents Active</div>
    
    <div class="stats">
        <div><span class="stat-value">19</span> memories</div>
        <div><span class="stat-value">2</span> ghost traces</div>
        <div><span class="stat-value">6</span> fleet agents</div>
    </div>

    <div id="viz"></div>

    <div class="legend">
        <div class="legend-title">Fleet</div>
        <div class="legend-item"><span class="legend-dot" style="background:#6B8E9B"></span>SWIV üîÄ Captain</div>
        <div class="legend-item"><span class="legend-dot" style="background:#8F7E6B"></span>FORGE üî® Builder</div>
        <div class="legend-item"><span class="legend-dot" style="background:#7B6B8F"></span>OMEGA Œ© Systems</div>
        <div class="legend-item"><span class="legend-dot" style="background:#E8A060"></span>ALPHA üê∫ Markets</div>
        <div class="legend-item"><span class="legend-dot" style="background:#3AAFAF"></span>VANGUARD üõ°Ô∏è VPS</div>
        <div class="legend-item"><span class="legend-dot" style="background:#8B9EB0"></span>SIGNAL üì° Data</div>
        <div style="margin-top:12px;border-top:1px solid rgba(255,255,255,0.1);padding-top:10px;">
            <div class="legend-title">Traces</div>
            <div class="legend-item"><span class="legend-line" style="background:rgba(232,160,96,0.6)"></span>Ghost path</div>
        </div>
    </div>

    <script>
        const width = window.innerWidth;
        const height = window.innerHeight;

        const agents = {
            SWIV: { color: '#6B8E9B', emoji: 'üîÄ', label: 'SWIV', x: 0.3, y: 0.3 },
            FORGE: { color: '#8F7E6B', emoji: 'üî®', label: 'FORGE', x: 0.7, y: 0.3 },
            OMEGA: { color: '#7B6B8F', emoji: 'Œ©', label: 'OMEGA', x: 0.3, y: 0.7 },
            ALPHA: { color: '#E8A060', emoji: 'üê∫', label: 'ALPHA', x: 0.15, y: 0.8 },
            VANGUARD: { color: '#3AAFAF', emoji: 'üõ°Ô∏è', label: 'VANGUARD', x: 0.8, y: 0.2 },
            SIGNAL: { color: '#8B9EB0', emoji: 'üì°', label: 'SIGNAL', x: 0.85, y: 0.5 }
        };

        const memories = [
            { id: 1,  agent: 'SWIV',    domain: 'trading',        tags: ['canonical','critical'], text: 'Binary prediction markets are barrier-crossing, not mean reversion. Strike is fixed at window open.', resonance: 2 },
            { id: 2,  agent: 'SWIV',    domain: 'trading',        tags: ['canonical'],            text: 'ALWAYS read API docs before building. Not twice. Every time. Hard rule.', resonance: 2 },
            { id: 3,  agent: 'OMEGA',   domain: 'infrastructure', tags: ['critical'],             text: 'NEVER apply config changes while subagents are active. Restart kills all running sessions.', resonance: 0 },
            { id: 4,  agent: 'SWIV',    domain: 'infrastructure', tags: [],                      text: 'Remote infra: always connect via secure tunnel. Direct public IP access should be blocked by design.', resonance: 0 },
            { id: 5,  agent: 'FORGE',   domain: 'code',           tags: [],                      text: 'Framework-managed inputs need simulated keystrokes ‚Äî programmatic fill() skips internal state updates.', resonance: 0 },
            { id: 6,  agent: 'FORGE',   domain: 'infrastructure', tags: [],                      text: 'Symlinked temp directories cause silent failures in file upload pipelines. Always resolve real path.', resonance: 0 },
            { id: 7,  agent: 'SWIV',    domain: 'infrastructure', tags: [],                      text: 'Bot permissions must be granted BEFORE resource creation. Resources created before permissions = invisible.', resonance: 0 },
            { id: 8,  agent: 'SWIV',    domain: 'trading',        tags: ['proven'],              text: 'Data first, code second, money last. 500+ observations before calibration. Never trade without proven edge.', resonance: 2 },
            { id: 9,  agent: 'FORGE',   domain: 'code',           tags: [],                      text: 'Async job APIs return 202 IN_QUEUE before 200 OK. Poll loop must handle both or completions get missed.', resonance: 0 },
            { id: 10, agent: 'SWIV',    domain: 'research',       tags: [],                      text: 'Agent memory as resonance substrate is unexplored territory. Ghost traces of pre-collapse deliberation = inherited wisdom.', resonance: 0 },
            { id: 11, agent: 'SWIV',    domain: 'product',        tags: [],                      text: 'Static sites outperform over-engineered stacks for marketing pages. Ship fast, iterate.', resonance: 0 },
            { id: 12, agent: 'SWIV',    domain: 'product',        tags: [],                      text: 'AI video pipeline: scene prompts ‚Üí generation ‚Üí score ‚Üí narration ‚Üí assembly. Each stage is independent.', resonance: 0 },
            { id: 13, agent: 'FORGE',   domain: 'code',           tags: [],                      text: 'Video codec for streaming: yuv420p + 44100Hz + baseline profile + faststart. Higher settings cause decoder failures.', resonance: 0 },
            { id: 14, agent: 'ALPHA',   domain: 'trading',        tags: [],                      text: 'Market signal must come from underlying asset feed, not derivative contract price. Contract = consensus, not signal.', resonance: 0 },
            { id: 15, agent: 'SWIV',    domain: 'research',       tags: [],                      text: 'Discovery as Diffusion: agents find relevant data through semantic state-matching, not keyword search.', resonance: 0 },
            { id: 16, agent: 'VANGUARD',domain: 'infrastructure', tags: [],                      text: 'Headless nodes: browser automation requires dedicated hardware. Containerized 2GB instances OOM on Chromium.', resonance: 0 },
            { id: 17, agent: 'SWIV',    domain: 'trading',        tags: [],                      text: 'Entry timing is the multiplier. Identical edge at different entry prices = breakeven vs real profit.', resonance: 0 },
            { id: 18, agent: 'FORGE',   domain: 'code',           tags: [],                      text: 'Free public APIs rate-limit aggressively. Cache at source. 60s TTL prevents most 429s.', resonance: 0 },
            { id: 19, agent: 'SIGNAL',  domain: 'infrastructure', tags: [],                      text: 'Lightweight data collection agents cost near-zero. Sub-cent-per-day models = always-on fleet intelligence.', resonance: 0 },
        ];

        const ghosts = [
            { id: 'g1', agent: 'SWIV', domain: 'trading', collapsed_to: 'shadow mode first',  branches: [{label:'shadow first',weight:0.75},{label:'abort+respec',weight:0.15},{label:'go live now',weight:0.10}] },
            { id: 'g2', agent: 'SWIV', domain: 'product', collapsed_to: 'ship and iterate',   branches: [{label:'ship and iterate',weight:0.70},{label:'polish more',weight:0.20},{label:'rebuild from scratch',weight:0.10}] },

        const svg = d3.select('#viz').append('svg');
        const g = svg.append('g');

        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.3, 3])
            .on('zoom', (event) => g.attr('transform', event.transform));
        svg.call(zoom);

        // Create node data
        const agentNodes = Object.entries(agents).map(([key, data]) => ({
            id: key,
            type: 'agent',
            ...data,
            x: data.x * width,
            y: data.y * height
        }));

        const memoryNodes = memories.map((m, i) => {
            const agent = agents[m.agent];
            const angle = (i / memories.length) * Math.PI * 2 + (m.agent === 'SWIV' ? 0 : m.agent === 'FORGE' ? 2 : 4);
            const dist = m.resonance > 0 ? 120 + Math.random() * 80 : 160 + Math.random() * 100;
            return {
                ...m,
                type: 'memory',
                x: agent.x * width + Math.cos(angle) * dist,
                y: agent.y * height + Math.sin(angle) * dist,
                radius: m.resonance > 0 ? 8 : 5,
                color: agent.color
            };
        });

        const ghostNodes = ghostTraces.map((g, i) => {
            const agent = agents[g.agent];
            return {
                ...g,
                type: 'ghost',
                x: agent.x * width + 200 + i * 80,
                y: agent.y * height + 150 + i * 40,
                radius: 6,
                color: '#E8A060'
            };
        });

        // Add placeholder node for Alpha
        const alphaPlaceholder = {
            id: 'alpha-placeholder',
            type: 'placeholder',
            agent: 'ALPHA',
            text: 'awaiting signal',
            x: agents.ALPHA.x * width + 100,
            y: agents.ALPHA.y * height + 80,
            radius: 4,
            color: agents.ALPHA.color
        };

        const allNodes = [...agentNodes, ...memoryNodes, ...ghostNodes, alphaPlaceholder];

        // Create links
        const links = [];
        
        // Connect memories to agents
        memoryNodes.forEach(m => {
            links.push({ source: m.agent, target: `memory-${m.id}`, type: 'memory' });
        });

        // Connect ghost traces to agents
        ghostNodes.forEach(g => {
            links.push({ source: g.agent, target: `ghost-${g.id}`, type: 'ghost' });
        });

        // Connect Vanguard to infra memories (4, 7)
        links.push({ source: 'VANGUARD', target: 'memory-4', type: 'shared' });
        links.push({ source: 'VANGUARD', target: 'memory-7', type: 'shared' });

        // Connect Signal to infra/research memories
        links.push({ source: 'SIGNAL', target: 'memory-4', type: 'shared' });
        links.push({ source: 'SIGNAL', target: 'memory-10', type: 'shared' });
        links.push({ source: 'SIGNAL', target: 'memory-16', type: 'shared' });

        // Connect placeholder to Alpha
        links.push({ source: 'ALPHA', target: 'alpha-placeholder', type: 'placeholder' });

        // Fix node references in links
        links.forEach(link => {
            if (typeof link.source === 'string') {
                link.source = allNodes.find(n => n.id === link.source || (n.type === 'memory' && n.id === parseInt(link.source.split('-')[1])) || (n.type === 'ghost' && n.id === link.source.split('-')[1]));
            }
            if (typeof link.target === 'string') {
                if (link.target.startsWith('memory-')) {
                    link.target = memoryNodes.find(n => n.id === parseInt(link.target.split('-')[1]));
                } else if (link.target.startsWith('ghost-')) {
                    link.target = ghostNodes.find(n => n.id === link.target.split('-')[1]);
                } else if (link.target === 'alpha-placeholder') {
                    link.target = alphaPlaceholder;
                } else {
                    link.target = allNodes.find(n => n.id === link.target);
                }
            }
        });

        // Add note for Alpha
        const alphaNote = {
            id: 'alpha-note',
            type: 'note',
            text: 'Markets. Signals. Edges. Waking up.',
            x: agents.ALPHA.x * width,
            y: agents.ALPHA.y * height + 50
        };

        // Simulation
        const simulation = d3.forceSimulation(allNodes)
            .force('link', d3.forceLink(links).id(d => d.id).distance(d => d.type === 'shared' ? 180 : d.type === 'ghost' ? 120 : 100).strength(0.3))
            .force('charge', d3.forceManyBody().strength(d => d.type === 'agent' ? -800 : -200))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(d => d.radius + 15))
            .force('x', d3.forceX(d => d.type === 'agent' ? agents[d.id].x * width : width / 2).strength(d => d.type === 'agent' ? 0.3 : 0.05))
            .force('y', d3.forceY(d => d.type === 'agent' ? agents[d.id].y * height : height / 2).strength(d => d.type === 'agent' ? 0.3 : 0.05));

        // Draw links
        const linkElements = g.append('g')
            .selectAll('line')
            .data(links)
            .enter()
            .append('line')
            .attr('class', 'link')
            .attr('stroke', d => d.type === 'ghost' ? '#E8A060' : d.type === 'shared' ? '#3AAFAF' : '#4a5a63')
            .attr('stroke-width', d => d.type === 'ghost' ? 2 : 1)
            .attr('stroke-dasharray', d => d.type === 'ghost' ? '5,5' : d.type === 'placeholder' ? '3,3' : null);

        // Draw nodes
        const nodeGroups = g.append('g')
            .selectAll('g')
            .data(allNodes)
            .enter()
            .append('g')
            .attr('class', 'node')
            .call(d3.drag()
                .on('start', (event, d) => {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                })
                .on('drag', (event, d) => {
                    d.fx = event.x;
                    d.fy = event.y;
                })
                .on('end', (event, d) => {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }));

        // Resonance glow for high-resonance memories
        nodeGroups.filter(d => d.resonance > 0)
            .append('circle')
            .attr('class', 'resonance-ring')
            .attr('r', d => d.radius * 2.5)
            .attr('fill', d => d.color)
            .attr('opacity', 0.15);

        // Main node circles
        nodeGroups.append('circle')
            .attr('r', d => d.radius)
            .attr('fill', d => d.color)
            .attr('opacity', d => d.type === 'ghost' ? 0.4 : d.type === 'placeholder' ? 0.5 : 0.9);

        // Agent glow rings
        nodeGroups.filter(d => d.type === 'agent')
            .append('circle')
            .attr('class', 'agent-glow')
            .attr('r', d => d.radius * 3)
            .attr('fill', 'none')
            .attr('stroke', d => d.color)
            .attr('stroke-width', 2)
            .attr('opacity', 0.3);

        // Agent labels
        nodeGroups.filter(d => d.type === 'agent')
            .append('text')
            .attr('class', 'agent-label')
            .attr('x', 0)
            .attr('y', d => -d.radius - 15)
            .attr('text-anchor', 'middle')
            .attr('fill', d => d.color)
            .text(d => `${d.label} ${d.emoji}`);

        // Agent note for Alpha
        nodeGroups.filter(d => d.id === 'ALPHA')
            .append('text')
            .attr('class', 'ghost-label')
            .attr('x', 0)
            .attr('y', d => d.radius + 35)
            .attr('text-anchor', 'middle')
            .text('Markets. Signals. Edges. Waking up.');

        // Memory labels (truncated)
        nodeGroups.filter(d => d.type === 'memory')
            .append('text')
            .attr('font-size', 9)
            .attr('x', 0)
            .attr('y', d => d.radius + 12)
            .attr('text-anchor', 'middle')
            .attr('fill', '#6B8E9B')
            .text(d => d.text.length > 30 ? d.text.substring(0, 30) + '...' : d.text);

        // Ghost labels
        nodeGroups.filter(d => d.type === 'ghost')
            .append('text')
            .attr('class', 'ghost-label')
            .attr('x', 0)
            .attr('y', d => d.radius + 15)
            .attr('text-anchor', 'middle')
            .text(d => `‚Üí ${d.decision}`);

        // Placeholder label
        nodeGroups.filter(d => d.type === 'placeholder')
            .append('text')
            .attr('font-size', 8)
            .attr('x', 0)
            .attr('y', d => d.radius + 10)
            .attr('text-anchor', 'middle')
            .attr('fill', d => d.color)
            .attr('opacity', 0.7)
            .text(d => d.text);

        // Tooltip
        const tooltip = d3.select('body').append('div')
            .attr('class', 'tooltip')
            .style('opacity', 0);

        nodeGroups
            .on('mouseenter', function(event, d) {
                d3.select(this).select('circle').attr('opacity', 1);
                
                let content = '';
                if (d.type === 'agent') {
                    content = `<div class="tooltip-header">${d.label} ${d.emoji}</div>`;
                    if (d.id === 'ALPHA') content += '<div class="tooltip-content">Markets. Signals. Edges. Waking up.</div>';
                    else if (d.id === 'VANGUARD') content += '<div class="tooltip-content">VPS Fleet Commander. Infrastructure guardian.</div>';
                    else if (d.id === 'SIGNAL') content += '<div class="tooltip-content">VPS Data Collector. Quiet presence.</div>';
                    else content += `<div class="tooltip-content">Fleet ${d.label.toLowerCase()}</div>`;
                } else if (d.type === 'memory') {
                    content = `<div class="tooltip-header">${d.agent} ‚Äî ${d.domain}</div>`;
                    content += `<div class="tooltip-content">${d.text}</div>`;
                    if (d.tags.length > 0) content += `<div style="margin-top:8px;color:#E8A060">${d.tags.join(' ‚Ä¢ ')}</div>`;
                    if (d.resonance > 0) content += `<div style="margin-top:4px;color:#E8A060">üî• resonance: ${d.resonance}</div>`;
                } else if (d.type === 'ghost') {
                    content = `<div class="tooltip-header">üëª Ghost Trace</div>`;
                    content += `<div class="tooltip-content">${d.text}</div>`;
                    content += `<div style="margin-top:8px;color:#E8A060">‚Üí ${d.decision}</div>`;
                    content += `<div style="margin-top:4px;font-size:10px;opacity:0.7">${d.reason}</div>`;
                } else if (d.type === 'placeholder') {
                    content = `<div class="tooltip-header">${d.agent}</div>`;
                    content += `<div class="tooltip-content">Awaiting first memory...</div>`;
                }

                tooltip.transition().duration(200).style('opacity', 1);
                tooltip.html(content)
                    .style('left', (event.pageX + 15) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseleave', function(event, d) {
                d3.select(this).select('circle').attr('opacity', d => d.type === 'ghost' ? 0.4 : d.type === 'placeholder' ? 0.5 : 0.9);
                tooltip.transition().duration(200).style('opacity', 0);
            });

        // Update positions on tick
        simulation.on('tick', () => {
            linkElements
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            nodeGroups
                .attr('transform', d => `translate(${d.x},${d.y})`);
        });

        // Initial center
        simulation.alpha(1).restart();

        // Handle resize
        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            svg.attr('width', newWidth).attr('height', newHeight);
            simulation.force('center', d3.forceCenter(newWidth / 2, newHeight / 2));
            simulation.alpha(0.3).restart();
        });
    </script>
</body>
</html>
